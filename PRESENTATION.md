# Презентация промежуточного демо
## Распределенная система редактирования документов с AI-агентами

---

## Слайд 1: Титульный - "Что мы сделали"

### На слайде:
**Заголовок:** Распределенная система коллективного редактирования с AI-агентами

**Подзаголовки:**
- 5 микросервисов (Text, Chat, Analytics, AI Agent, Load Balancer)
- Frontend на Next.js 15
- Production deployment с SSL
- 36 unit-тестов

**Картинка:** Схема архитектуры (можно нарисовать от руки или использовать screenshot архитектуры из README)

### Что говорить:
"Привет! Мы делаем систему, где несколько AI-агентов одновременно редактируют один документ. Представьте, что вы пишете курсовую, а несколько умных помощников параллельно её улучшают — добавляют детали, исправляют стиль, дополняют идеи. Но они не перезаписывают друг друга, а работают через специальный протокол с намерениями и подтверждениями.

У нас получилось реализовать полноценную распределенную систему с пятью сервисами. Есть три узла Text Service для хранения документа с репликацией между ними, Chat Service на Redis для обмена сообщениями между агентами, Analytics для сбора метрик, сами AI-агенты на Node.js, и Load Balancer для распределения нагрузки. Плюс мы сделали веб-интерфейс на Next.js, где можно всё это видеть в реальном времени.

Всё это работает в продакшене с автоматическими SSL-сертификатами через Let's Encrypt."

---

## Слайд 2: Демонстрация работы протокола

### На слайде:
**Заголовок:** Как работает редактирование

**Текст:**
Протокол из 4 фаз на каждую правку:
1. Агент генерирует намерение (intent)
2. Подтверждает его после проверки контекста
3. Создаёт конкретную операцию (insert/replace/delete)
4. Финальное ревью перед применением

**Пример результата:**
- Версия 1: "Документ начинается здесь."
- Версия 17: "В двадцать третьем веке города светились мягким неоновым сиянием..."
- Версия 31: Полноценный рассказ на несколько абзацев

### Что говорить:
"Сначала я запустил демо-файл `multi_agent_editor_demo_Version2.py` с 10 агентами, чтобы понять, как должна работать система. За один прогон получилось 31 версия документа. Начинали с простой заглушки 'Документ начинается здесь', а агенты постепенно написали целый научно-фантастический рассказ про роботов, которые хотят стать людьми.

Главное — каждая правка проходит через строгий протокол. Агент не может просто взять и изменить текст. Сначала он формирует намерение — что хочет сделать. Потом перечитывает документ и чат, проверяет, не устарело ли намерение. Дальше генерирует конкретную операцию — например, 'вставить после слова X текст Y'. И в самом конце делает финальное ревью — может отменить, если увидит, что кто-то уже сделал похожее изменение.

Это защищает от конфликтов и делает редактирование осмысленным, а не хаотичным."

---

## Слайд 3: Архитектура и распределенность

### На слайде:
**Заголовок:** Распределенные компоненты

**Диаграмма или список:**
```
[Frontend] → [Load Balancer] → [Text Service A/B/C]
                              ↓
                         [Chat Service (Redis)]
                              ↓
                         [AI Agents (×2)]
                              ↓
                         [Analytics Service]
```

**Ключевые свойства:**
- Репликация: 3 узла Text Service (eventual consistency)
- Concurrency: Транзакции PostgreSQL
- Safety: No data loss, rollback при ошибках
- Liveness: Автовосстановление узлов
- Fault tolerance: Health checks + failover

### Что говорить:
"Мы реализовали все основные свойства распределенных систем из курса.

**Репликация**: Документ хранится одновременно на трёх узлах — в Москве, Питере и Новосибирске, условно. Когда один узел получает правку, он реплицирует её на остальные два. Это eventual consistency — в итоге все узлы придут к одному состоянию, но не мгновенно.

**Concurrency**: Несколько агентов могут пытаться редактировать одновременно. Мы используем транзакции в PostgreSQL — если два агента правят одно и то же место, один откатится и попробует снова.

**Safety**: Никакие данные не теряются. Если узел упал во время записи — транзакция откатывается. Если узел был выключен — при включении он подтянет пропущенные правки у соседей.

**Liveness**: Load balancer постоянно проверяет узлы. Если узел не отвечает — трафик идёт на живые. Когда узел восстанавливается — автоматически возвращается в работу.

Все операции над текстом используют якоря (anchor-based) — агент ищет конкретный кусок текста и правит относительно него. Это надёжнее, чем позиции типа 'вставить на 42-й символ'."

---

## Слайд 4: Трудности и решения

### На слайде:
**Заголовок:** С чем столкнулись

**Проблема 1:** Подсчёт API-вызовов
- Думали: 1 правка = 1 запрос
- Реально: 1 правка = 4 запроса (intent → confirm → generate → review)
- Решение: Снизили с 3 агентов×2 правки до 2 агентов×1 правка (24 → 8 запросов)

**Проблема 2:** Конфликты при параллельных правках
- Агенты пытались править одно место одновременно
- Решение: PostgreSQL транзакции + retry logic с exponential backoff

**Проблема 3:** Deployment автоматизация
- Надо установить Docker, настроить SSL, запустить все сервисы
- Решение: GitHub Actions workflow с автоматической установкой всего необходимого

### Что говорить:
"Было несколько сложных моментов.

Первое — мы сначала неправильно рассчитали бюджет на OpenAI API. Думали, что одна правка = один запрос. А по факту протокол требует четыре запроса: генерация намерения, подтверждение, создание операции и финальное ревью. Получалось вместо 6 запросов — 24! Пришлось снизить количество агентов и правок на агента, чтобы уложиться в 10 запросов.

Второе — конфликты при параллельной работе. Когда два агента одновременно пытаются править один абзац, один должен откатиться. Мы решили это через транзакции PostgreSQL с уровнем изоляции read committed. Плюс добавили retry logic с экспоненциальной задержкой — если правка не прошла, агент подождёт немного и попробует снова, учитывая новые изменения.

Третье — deployment. Нужно было сделать так, чтобы после пуша в main всё само задеплоилось на сервер с нуля: установился Docker, поднялись все сервисы, получились SSL-сертификаты. Это заняло время, но теперь работает автоматически через GitHub Actions."

---

## Слайд 5: Демо и результаты

### На слайде:
**Заголовок:** Что получилось

**Статистика:**
- 5 сервисов: 100% готовы
- 36 unit-тестов: все проходят
- 0 security alerts (CodeQL)
- Production deployment: работает

**Скриншоты (что показать):**
1. Frontend: главная страница с инициализацией документа
2. Страница документа с версионированием и историей правок
3. Страница чата с сообщениями агентов
4. Страница аналитики с графиками

**Live demo:** Открыть сайт и показать real-time обновления

### Что говорить:
"В итоге у нас полностью рабочая система.

Заходим на сайт — вот главная страница. Можем создать новый документ, указать тему. Агенты сразу начинают работать.

Переходим на страницу документа — здесь видим текущую версию в реальном времени. Каждые 3 секунды обновляется автоматически. Видна история правок — кто, когда, что изменил.

Страница чата показывает все сообщения агентов — их намерения, комментарии друг к другу. Это тоже обновляется автоматически каждые 2 секунды.

И есть страница аналитики с метриками: сколько правок сделано, сколько токенов потрачено, сколько агентов активны. Можно выбрать период — последний час, сутки или неделя.

Все 36 тестов проходят — есть unit-тесты для каждого сервиса, интеграционные и e2e. CodeQL не нашёл уязвимостей. Вся система задеплоена в продакшене с автоматическими SSL-сертификатами.

Основной челлендж был в правильной реализации распределённых свойств — репликация, консистентность, обработка отказов. И в корректном подсчёте бюджета на API-вызовы. Но мы это всё решили, и система работает стабильно."

---

## Инструкции для демонстрации

### Перед презентацией:
1. Открыть в браузере:
   - Главную страницу frontend
   - Страницу документа
   - Страницу чата
   - Страницу аналитики

2. Подготовить скриншоты:
   - Архитектурная схема (из README или нарисовать)
   - Страницы frontend (сделать 4 скриншота)
   - Графики из аналитики
   - Пример версий документа (версия 1 → 17 → 31)

3. Проверить, что всё работает:
   ```bash
   docker-compose up -d
   # Подождать 30 секунд
   curl http://localhost/api/document/current
   ```

### Во время демо:
- **Слайд 1**: Показать общую схему, объяснить идею
- **Слайд 2**: Показать пример трансформации текста (версии 1, 17, 31)
- **Слайд 3**: Объяснить архитектуру на схеме
- **Слайд 4**: Честно рассказать про проблемы
- **Слайд 5**: 
  - Открыть live сайт
  - Показать создание документа
  - Показать real-time обновления
  - Показать аналитику

### Ключевые месседжи:
1. "Мы реализовали полноценную распределённую систему, не макет"
2. "Протокол с намерениями предотвращает конфликты"
3. "Все свойства из курса: replication, concurrency, safety, liveness"
4. "Столкнулись с реальными проблемами распределённых систем и решили их"
5. "Система работает в продакшене с автоматическим deployment"

---

## Дополнительные материалы для вопросов

**Q: Почему именно такой протокол с 4 фазами?**
A: Чтобы агенты не конфликтовали. Если агент видит, что кто-то уже сделал похожее — он может отменить своё намерение на любой фазе.

**Q: Как обрабатываются конфликты?**
A: PostgreSQL транзакции + last-write-wins по timestamp. Проигравший откатывается и пробует снова с новой версией документа.

**Q: Что если узел упадёт?**
A: Load balancer переключит трафик на живые узлы. При восстановлении узел подтянет пропущенные правки через catch-up механизм.

**Q: Сколько стоит запуск?**
A: ~$0.01-0.02 за сессию с 2 агентами и 1 правкой на агента (8 API вызовов к OpenAI).

**Q: Можно масштабировать?**
A: Да, агенты stateless — можно запустить хоть 100. Узлы Text Service тоже можно добавлять. Bottleneck только в OpenAI API rate limits.
