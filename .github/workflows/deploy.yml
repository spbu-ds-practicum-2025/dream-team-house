name: Deploy to Production

on:
  push:
    branches: [main]
  workflow_dispatch:

permissions:
  contents: read

jobs:
  deploy:
    name: Deploy to Server
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install sshpass and prepare known_hosts
        env:
          DEPLOY_HOST: ${{ secrets.DEPLOY_HOST }}
          DEPLOY_PORT: ${{ secrets.DEPLOY_PORT }}
        run: |
          sudo apt-get update
          sudo apt-get install -y sshpass
          mkdir -p ~/.ssh
          if [ -n "${DEPLOY_PORT:-}" ]; then
            ssh-keyscan -p "$DEPLOY_PORT" -H "$DEPLOY_HOST" >> ~/.ssh/known_hosts
          else
            ssh-keyscan -H "$DEPLOY_HOST" >> ~/.ssh/known_hosts
          fi

      - name: Deploy to server
        env:
          DEPLOY_HOST: ${{ secrets.DEPLOY_HOST }}
          DEPLOY_USER: ${{ secrets.DEPLOY_USER }}
          DEPLOY_PASS: ${{ secrets.DEPLOY_PASS }}
          DEPLOY_PORT: ${{ secrets. DEPLOY_PORT }}
          TEXT_SERVICE_A_DOMAIN: ${{ secrets.TEXT_SERVICE_A_DOMAIN }}
          TEXT_SERVICE_B_DOMAIN: ${{ secrets.TEXT_SERVICE_B_DOMAIN }}
          TEXT_SERVICE_C_DOMAIN: ${{ secrets.TEXT_SERVICE_C_DOMAIN }}
          ANALYTICS_SERVICE_DOMAIN: ${{ secrets.ANALYTICS_SERVICE_DOMAIN }}
          CHAT_SERVICE_DOMAIN: ${{ secrets. CHAT_SERVICE_DOMAIN }}
          FRONTEND_DOMAIN:  ${{ secrets.FRONTEND_DOMAIN }}
          OPENAI_API_KEY: ${{ secrets. OPENAI_API_KEY }}
          CERTBOT_EMAIL:  ${{ secrets.CERTBOT_EMAIL }}
        run: |
          # Create deployment script
          cat > deploy.sh << 'DEPLOY_SCRIPT'
          #!/bin/bash
          set -e
          
          echo "=== Starting deployment ==="
          SSH_PORT_OPTION=""
          SCP_PORT_OPTION=""
          if [ -n "${DEPLOY_PORT:-}" ]; then
              SSH_PORT_OPTION="-p ${DEPLOY_PORT}"
              SCP_PORT_OPTION="-P ${DEPLOY_PORT}"
          fi
          SSH_BASE_OPTS="-o StrictHostKeyChecking=yes -o PreferredAuthentications=password -o PubkeyAuthentication=no ${SSH_PORT_OPTION}"
          SCP_BASE_OPTS="-o StrictHostKeyChecking=yes -o PreferredAuthentications=password -o PubkeyAuthentication=no ${SCP_PORT_OPTION}"
          
          # Check if Docker is installed
          if ! command -v docker &> /dev/null; then
              echo "Docker not found. Installing Docker..."
              curl -fsSL https://get.docker.com -o get-docker.sh
              sudo sh get-docker.sh
              sudo usermod -aG docker $USER
              rm get-docker.sh
              echo "Docker installed successfully"
          else
              echo "Docker is already installed"
          fi
          
          # Check if Docker Compose is installed (v2 style)
          if ! docker compose version &> /dev/null; then
              echo "Docker Compose not found. Installing Docker Compose..."
              sudo curl -L "https://github.com/docker/compose/releases/latest/download/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
              sudo chmod +x /usr/local/bin/docker-compose
              # Create symlink for docker compose plugin
              sudo mkdir -p /usr/local/lib/docker/cli-plugins
              sudo ln -sf /usr/local/bin/docker-compose /usr/local/lib/docker/cli-plugins/docker-compose
              echo "Docker Compose installed successfully"
          else
              echo "Docker Compose is already installed"
          fi
          
          # Create deployment directory
          sudo mkdir -p /opt/dream-team-house
          sudo chown ${DEPLOY_USER}:${DEPLOY_USER} /opt/dream-team-house
          
          echo "Checking SSH connectivity..."
          sshpass -p "${DEPLOY_PASS}" ssh ${SSH_BASE_OPTS} "${DEPLOY_USER}@${DEPLOY_HOST}" "whoami && hostname && pwd && ls -ld /opt/dream-team-house"
          
          # Copy files to server
          echo "Copying files to server..."
          sshpass -p "${DEPLOY_PASS}" scp ${SCP_BASE_OPTS} -r ./* "${DEPLOY_USER}@${DEPLOY_HOST}":/opt/dream-team-house/
          
          # Create .env file on server
          echo "Creating .env file on server..."
          cat > . env. tmp << EOF
          OPENAI_API_KEY=${OPENAI_API_KEY}
          CERTBOT_EMAIL=${CERTBOT_EMAIL}
          TEXT_SERVICE_A_DOMAIN=${TEXT_SERVICE_A_DOMAIN}
          TEXT_SERVICE_B_DOMAIN=${TEXT_SERVICE_B_DOMAIN}
          TEXT_SERVICE_C_DOMAIN=${TEXT_SERVICE_C_DOMAIN}
          ANALYTICS_SERVICE_DOMAIN=${ANALYTICS_SERVICE_DOMAIN}
          CHAT_SERVICE_DOMAIN=${CHAT_SERVICE_DOMAIN}
          FRONTEND_DOMAIN=${FRONTEND_DOMAIN}
          POSTGRES_PASSWORD=\$(openssl rand -base64 32)
          EOF
          
          sshpass -p "${DEPLOY_PASS}" scp ${SCP_BASE_OPTS} . env.tmp "${DEPLOY_USER}@${DEPLOY_HOST}":/opt/dream-team-house/. env
          rm .env.tmp
          
          # Execute deployment commands on server
          echo "Executing deployment on server..."
          sshpass -p "${DEPLOY_PASS}" ssh ${SSH_BASE_OPTS} "${DEPLOY_USER}@${DEPLOY_HOST}" bash << 'REMOTE_COMMANDS'
          set -e
          cd /opt/dream-team-house
          
          # Generate POSTGRES_PASSWORD if not exists
          if !  grep -q "POSTGRES_PASSWORD=" .env 2>/dev/null || [ -z "$(grep POSTGRES_PASSWORD= .env | cut -d= -f2)" ]; then
              echo "POSTGRES_PASSWORD=$(openssl rand -base64 32)" >> .env
          fi
          
          echo "=== Environment file created ==="
          
          # Stop existing containers (use docker compose v2 syntax)
          echo "Stopping existing containers..."
          docker compose -f docker-compose.prod. yml down 2>/dev/null || true
          
          # Build and start services
          echo "Building and starting services..."
          docker compose -f docker-compose.prod.yml up -d --build
          
          # Wait for services to be healthy
          echo "Waiting for services to start..."
          sleep 30
          
          # Check service status
          echo "=== Service Status ==="
          docker compose -f docker-compose.prod. yml ps
          
          echo "=== Deployment completed ==="
          REMOTE_COMMANDS
          
          echo "Deployment complete!"
          echo "Application should be available at: https://${FRONTEND_DOMAIN}"
          DEPLOY_SCRIPT
          
          chmod +x deploy.sh
          bash deploy.sh